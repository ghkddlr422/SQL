--2020/08/03

select table_name from user_tables;

--DDL (data definition Language
--Create() / Alter() / Drop() / Truncate() / Rename()
--UID ->  COLUMN 이름       SQL = 행과 열로 이루어진 테이블 ROWS(HORIZONTAL)/COLUMN(VERTICAL)

CREATE TABLE TEST1(
U_ID VARCHAR2(10),
U_NAME VARCHAR2(20),
U_DATE DATE);

SELECT * FROM TEST1;
DESC TEST1;
INSERT INTO TEST1 VALUES('cksql96','HCH','2020-08-03');

--문자열인경우
--CHAR(10) - 10BYTES PIXEL
--VARCHAR2(10) - 10BYTES VARIABLE
--한글은 - > 황 -> ㅎ ㅗ ㅏ ㅇ -> 4BYTES

--숫자인 경우
--NMBER(X,Y)    X BYTE를 쓰는데, 그중 Y바이트를 소수점으로 쓴다. 예를 들어 (5,2)일시, 
--소수점 없이 5자리를 쓸수도 있지만 소수점은 2자리가 넘어갈시 반올림으로 2자리만 만들고 끝.

--ALTER()    -> 개조하다.
CREATE TABLE T_STUDENT
AS --생략 불가능
SELECT * FROM STUDENT
WHERE STU_DEPT='기계';
COLUMN
DESC T_STUDENT;
SELECT * FROM T_STUDENT;

ALTER TABLE T_STUDENT
ADD(ARMY CHAR(1));         --COLUMN 하나 늘리기.

ALTER TABLE T_STUDENT
MODIFY(ARMY NUMBER);       --COLUMN 타입 바꾸기. (NUMBER 뒤에 아무것도 안붙으면 무제한으로 넣을수 있다.

ALTER TABLE T_STUDENT
DROP(ARMY);                --COLUMN 없애기.

--INSERT 는 ROWS 관련, ALTER는 COLUMN 관련.

--TABLE 이름 변경 , RENAME
DESC T_STUDENT;

RENAME T_STUDENT TO TEST_STUDENT;

DESC TEST_STUDENT;

--TRUNCATE() -> 잘라버린다. DELETE 삭제, TRUNCATE 잘라버린다. -> 완전 삭제. ROLLBACK 해도 안된다. DELETE + COMMIT 합쳐놓은거와 같다.
TRUNCATE TABLE TEST_STUDENT;
SELECT * FROM TEST_STUDENT;

--TABLE 삭제 DROP()
DROP TABLE TEST_STUDENT;

--CONSTRAINT   - 제약 조건 - FOR DATA IMMUNITY(데이터 면역)  
--NULL값이 있으면 안된다,       UNIQUE(중복X),         PRIMARY ( NOT NULL + UNIQUE),         CHECK(범위,구분...)
--FOREIGN(다른 TABLE의 PRIMARY KEY) ......         NN = CK = C, UK=U, PK =P, FK=R, NN(NOT NULL) UK(UNIQUE), PK(PRIMARY), CK(CHECK), FK = (FOREIGN)

--NOT NULL
CREATE TABLE T_STUDENT(
STU_NO CHAR(9),
STU_NAME VARCHAR2(12),
STU_DEPT VARCHAR2(20) CONSTRAINT N_STU_DEPT NOT NULL,           --NOT NULL
STU_GRADE NUMBER(1),
STU_CLASS CHAR(1),
STU_HEIGHT NUMBER(5,2),
STU_WEIGHT NUMBER(5,2) );

SELECT * FROM T_STUDENT;
DESC T_STUDENT;
--VERIFY FOR CONSTRAINT...
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='T_STUDENT';

--UNIQUE(중복X)
CREATE TABLE TT_STUDENT(
STU_NO CHAR(9),
STU_NAME VARCHAR(12) CONSTRAINT U_STU_NAME UNIQUE,              --UNIQUE
STU_DEPT VARCHAR2(20) CONSTRAINT NN_STU_DEPT NOT NULL,           --NOT NULL
STU_GRADE NUMBER(1) );
--VERIFY FOR CONSTRAINT...
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='TT_STUDENT';

--하기전 정리 우선
DROP TABLE T_STUDENT;
--PRIMARY(NN + UK)
CREATE TABLE T_STUDENT(
STU_NO CHAR(9),
STU_NAME VARCHAR2(12) CONSTRAINT UNIQUE_STU_NAME UNIQUE,
STU_DEPT VARCHAR2(20) CONSTRAINT NULL_STU_DEPT NOT NULL,
STU_GRADE NUMBER(1),
STU_CLASS CHAR(1),
STU_GENDER CHAR(1),
STU_HEIGHT NUMBER(5,2),
STU_WEIGHT NUMBER(5,2),
CONSTRAINT PRIMARY_STU_NO PRIMARY KEY(STU_NO) );
--VERIFY FOR CONSTRAINT...
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='T_STUDENT';

--FOREIGN KEY
CREATE TABLE T_ENROL(
SUB_NO CHAR(3),
STU_NO CHAR(9),
ENR_GRADE NUMBER(3),
CONSTRAINT ENR_SUB_NO_FK1 FOREIGN KEY(SUB_NO) REFERENCES SUBJECT(SUB_NO),
CONSTRAINT ENR_STU_NO_FK1 FOREIGN KEY(STU_NO) REFERENCES STUDENT(STU_NO),
CONSTRAINT ENR_PK1 PRIMARY KEY(SUB_NO,STU_NO) );
--VERIFY FOR CONSTRAINT...
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='T_ENROL';

DROP TABLE T_STUDENT;
--CHECK
CREATE TABLE T_STUDENT(
STU_NO CHAR(9),
STU_NAME VARCHAR2(12) CONSTRAINT UK_STU_NAME UNIQUE,
STU_DEPT VARCHAR2(20) CONSTRAINT NX_STU_DEPT NOT NULL,
STU_GRADE NUMBER(1),
STU_GENDER CHAR(1) CONSTRAINT C_STU_GENDER CHECK(STU_GENDER IN('M','F')),
STU_HEIGHT NUMBER(5,2),
STU_WEIGHT NUMBER(5,2),
CONSTRAINT PK_STU_NO PRIMARY KEY(STU_NO) );
--VERIFY FOR CONSTRAINT...
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='T_STUDENT';

ALTER TABLE T_ENROL
DROP CONSTRAINT ENR_SUB_NO_FK1 CASCADE;         --CASCADE 종속, 상속같은 개념

-------------------------------------------------------
-------------------------------------------------------
--VIEW -> 독립적인 테이블 INDEX -> SEARCHING 을 할때 기준을 정해줌.
CREATE OR REPLACE VIEW V_STUDENT1
AS
SELECT * FROM STUDENT
WHERE STU_DEPT='컴퓨터정보';
--CMD 관리자 권한으로 실행후, SQLPLUS치고, SYSTEM 치고, 123456 치고 grant create view to scott; 해주면 실행 된다.

SELECT * FROM V_STUDENT1;

CREATE VIEW V_ENROL1
AS
SELECT SUB_NAME, A.SUB_NO, STU_NO, ENR_GRADE
FROM ENROL A, SUBJECT B
WHERE A.SUB_NO = B.SUB_NO;

SELECT * FROM V_ENROL1;

--INDEX
CREATE INDEX I_STU_NAME ON STUDENT(STU_NAME);
CREATE INDEX I_STU_NO_STU_NAME ON STUDENT(STU_NO,STU_NAME);

SELECT * FROM STUDENT;

DROP INDEX I_STU_NAME;

--SEQUENCE
CREATE SEQUENCE SEQ1
INCREMENT BY 2              --2를 늘린다.
START WITH 1000             --시작하는 숫자
MAXVALUE 10000;             --최대 숫자

SELECT SEQ1.NEXTVAL FROM DUAL;

--select table_name
--from user_tables

--#sql , #erd => entity , relation, diagram

select table_name
from user_tables;

create table venrol
as
select * from 